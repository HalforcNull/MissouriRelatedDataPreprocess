in_between_var_v2 = t(d_1)%*%d_1 + t(d_2)%*%d_2 + t(d_3)%*%d_3
a = mean_bar
b_1 = result.mean[1,]
b_2 = result.mean[2,]
b_3 = result.mean[3,]
d_1 = as.matrix(b_1-a)
d_2 = as.matrix(b_2-a)
d_3 = as.matrix(b_3-a)
in_between_var_v2 = t(d_1)%*%d_1 + t(d_2)%*%d_2 + t(d_3)%*%d_3
k <- solve(with_in_var) %*% in_between_var_v2
ev <- eigen(k)
ev$vectors
k <- solve(with_in_var) %*% in_between_var
ev <- eigen(k)
ev$vectors
dat <- wines
head(dat)
class.labs <- dat[,1]
dat.no.labs <- as.matrix(dat[,-1])
n.classes <- length(unique(class.labs))
class.labs <- as.numeric(class.labs)
### get mean vectors
mean.vects <- by(dat.no.labs, class.labs, colMeans)
grand.mean <- colMeans(dat.no.labs)
### get class covariance matrices
cov.mats <- by (dat.no.labs, class.labs, cov)
### get within covariance
within.cov <- (1/length(class.labs))*Reduce("+", lapply(1:n.classes, function(x, class.labs, cov.mats){(sum(class.labs==x)-1)*cov.mats[[x]]}, class.labs, cov.mats))
### get between covariance
between.cov <- Reduce("+",lapply(1:n.classes, function(x, class.labs, mean.vects, grand.mean){sum(class.labs==x)/length(class.labs)*(mean.vects[[x]]-grand.mean)%*%t(mean.vects[[x]]-grand.mean)}, class.labs, mean.vects, grand.mean))
### do eigenvalue decomposition
eigen.vects <- eigen(solve(within.cov)%*%between.cov)$vectors
eigen.vals <- eigen(solve(within.cov)%*%between.cov)$values
View(eigen.vects)
my_Vec <- ev$vectors
View(my_Vec)
ev$values
k <- solve(with_in_var) %*% in_between_var_v2
ev <- eigen(k)
ev$values
k <- solve(with_in_var) %*% in_between_var
ev <- eigen(k)
ev$values
### transform data
proj.dat <- as.matrix(dat.no.labs)%*%matrix(as.numeric(eigen.vects[,1:(n.classes-1)]), dim(eigen.vects)[1], n.classes-1)
plot(proj.dat[,1], proj.dat[,2], col=class.labs, pch=16)
### predict classes
proj.means <- by(proj.dat, class.labs, colMeans)
proj.means <- rbind(proj.means[[1]], proj.means[[2]], proj.means[[3]])
pred.labs <- apply(proj.dat, 1, function(x, proj.means){which.min(diag((x-proj.means)%*%t(x-proj.means)))}, proj.means)
table(pred.labs, class.labs)
sum(pred.labs==class.labs)/length(class.labs)
### get within covariance
within.cov <- (1/length(class.labs))*Reduce("+", lapply(1:n.classes, function(x, class.labs, cov.mats){(sum(class.labs==x)-1)*cov.mats[[x]]}, class.labs, cov.mats))
View(within.cov)
View(with_in_var)
View(mean.vects)
View(result.preProb)
with_in_var = result.preProb[1,2] * result.cov$'South Africa' +
result.preProb[2,2] * result.cov$Germany        +
result.preProb[3,2] * result.cov$Italy
k <- solve(with_in_var) %*% in_between_var
ev <- eigen(k)
my_Vec <- ev$vectors
ev$values
result.preProb[1,2]
grand.mean
mean.vects
result.mean
### get mean vectors
mean.vects <- by(dat.no.labs, class.labs, colMeans)
mean.vects
cov.mats <- by (dat.no.labs, class.labs, cov)
cov.mats
in_between_var = result.preProb[1,2] * t(mean_diff_Matrix) %*% mean_diff_Matrix
in_between_var
length(class.labs)
result.preProb
# pre prob
t <- as.data.frame(table(wines[1]))
temp_result <- t[,2] / nrow(wines)
result.preProb <- cbind(t[1], temp_result)
result.preProb
result.preProb[,2] = c(1/3,1/3,1/3)
names(result.preProb) <- c('Country', 'PreProb')
rm(t, temp_result)
# mean
t<-wines
temp <- as.vector( by(t[,-1], t$Country, function(x) colMeans(x)))
result.mean <- rbind(temp$'South Africa', temp$Germany, temp$Italy)
rm(t, temp)
# variance
t<-wines
result.cov <- by(t[,-1], t$Country, cov)
rm(t)
# mean_bar = sum( preprob * mean )
mean_bar = as.data.frame( t(colSums( result.preProb[,2] * result.mean ) ))
with_in_var = result.preProb[1,2] * result.cov$'South Africa' +
result.preProb[2,2] * result.cov$Germany        +
result.preProb[3,2] * result.cov$Italy
mean_barMatrix = rbind(mean_bar,mean_bar,mean_bar)
mean_diff_Matrix = as.matrix(result.mean[,-1] - mean_barMatrix)
in_between_var = result.preProb[1,2] * t(mean_diff_Matrix) %*% mean_diff_Matrix
a = mean_bar
b_1 = result.mean[1,]
b_2 = result.mean[2,]
b_3 = result.mean[3,]
d_1 = as.matrix(b_1-a)
d_2 = as.matrix(b_2-a)
d_3 = as.matrix(b_3-a)
in_between_var_v2 = t(d_1)%*%d_1 + t(d_2)%*%d_2 + t(d_3)%*%d_3
var_bar = with_in_var+in_between_var
k <- solve(with_in_var) %*% in_between_var
ev <- eigen(k)
my_Vec <- ev$vectors
ev$values
dat <- wines
head(dat)
class.labs <- dat[,1]
dat.no.labs <- as.matrix(dat[,-1])
n.classes <- length(unique(class.labs))
class.labs <- as.numeric(class.labs)
### get mean vectors
mean.vects <- by(dat.no.labs, class.labs, colMeans)
grand.mean <- colMeans(dat.no.labs)
### get class covariance matrices
cov.mats <- by (dat.no.labs, class.labs, cov)
### get within covariance
within.cov <- (1/length(class.labs))*Reduce("+", lapply(1:n.classes, function(x, class.labs, cov.mats){(sum(class.labs==x)-1)*cov.mats[[x]]}, class.labs, cov.mats))
### get between covariance
between.cov <- Reduce("+",lapply(1:n.classes, function(x, class.labs, mean.vects, grand.mean){sum(class.labs==x)/length(class.labs)*(mean.vects[[x]]-grand.mean)%*%t(mean.vects[[x]]-grand.mean)}, class.labs, mean.vects, grand.mean))
### do eigenvalue decomposition
eigen.vects <- eigen(solve(within.cov)%*%between.cov)$vectors
eigen.vals <- eigen(solve(within.cov)%*%between.cov)$values
### transform data
proj.dat <- as.matrix(dat.no.labs)%*%matrix(as.numeric(eigen.vects[,1:(n.classes-1)]), dim(eigen.vects)[1], n.classes-1)
plot(proj.dat[,1], proj.dat[,2], col=class.labs, pch=16)
### predict classes
proj.means <- by(proj.dat, class.labs, colMeans)
proj.means <- rbind(proj.means[[1]], proj.means[[2]], proj.means[[3]])
pred.labs <- apply(proj.dat, 1, function(x, proj.means){which.min(diag((x-proj.means)%*%t(x-proj.means)))}, proj.means)
table(pred.labs, class.labs)
result.weight <- 1/cbind(t[1], temp_result)
result.weight <- 1/cbind(t[1], temp_result)[,2
]
# pre prob
t <- as.data.frame(table(wines[1]))
temp_result <- t[,2] / nrow(wines)
temp_result
result.weight <- 1/temp_result
result.weight <- cbind(t[1], 1/temp_result)[,2]
names(result.weight) <- c('Country', 'weight')
names(result.preProb) <- c('Country', 'PreProb')
library(Flury)
library(dplyr)
data("wines")
compute.withIn <- function(data, classColIndex){
names<-unique(data[classColIndex])
}
# pre prob
t <- as.data.frame(table(wines[1]))
temp_result <- t[,2] / nrow(wines)
result.weight <- cbind(t[1], 1/temp_result)[,2]
result.preProb[,2] = c(1/3,1/3,1/3)
names(result.weight) <- c('Country', 'weight')
names(result.preProb) <- c('Country', 'PreProb')
rm(t, temp_result)
# mean
t<-wines
temp <- as.vector( by(t[,-1], t$Country, function(x) colMeans(x)))
result.mean <- rbind(temp$'South Africa', temp$Germany, temp$Italy)
rm(t, temp)
result.mean
# variance
t<-wines
result.cov <- by(t[,-1], t$Country, cov)
result.cov$`South Africa` = result.cov$`South Africa` * result.weight[1,2]
result.cov$`South Africa` = result.cov$`South Africa` * as.numeric(result.weight[1,2])
result.weight[1,2]
result.weight[2]
result.cov$`South Africa` = result.cov$`South Africa` * as.numeric(result.weight[1])
result.cov$Germany = result.cov$Germany * as.numeric(result.weight[2])
result.cov$Italy = result.cov$Italy * as.numeric(result.weight[3])
rm(t)
cov.mats
with_in_var = result.preProb[1,2] * result.cov$'South Africa' +
result.preProb[2,2] * result.cov$Germany        +
result.preProb[3,2] * result.cov$Italy
View(with_in_var)
library(Matrix)
data <- mvnorm(n=20, mu, cov)
cov<-forceSymmetric(Matrix(rnorm(16), 4))
mu<-c(1,2,3,4)
data <- mvnorm(n=20, mu, cov)
data <- mvrnorm(n=20, mu, cov)
library(MASS)
data <- mvrnorm(n=20, mu, cov)
n <- 4
A <- matrix(runif(n^2)*2-1, ncol=n)
Sigma <- t(A) %*% A
data <- mvrnorm(n=20, mu, Sigma)
eg <- eigen(Sigma)
eg$vectors
B1 <- eg$vectors[1] %*% t(eg$values[1])
B1
B1 <- t(eg$values[1]) %*% eg$vectors[1]
B1
B1 <- eg$vectors[1] * t(eg$values[1])
B1
B1 <- eg$vectors[1] * eg$values[1]
B1
B1 <- t(eg$vectors[1]) %*% eg$vectors[1]
B1
B1 <-eg$vectors[1] %*% t(eg$vectors[1])
B1
B1 <-eg$vectors[1] * t(eg$vectors[1])
B1
B1 <-crossprod(eg$vectors[1])
B1
e <- eg$vectors[1]
e
eg$vectors
B1 <- t(eg$vectors[1,]) %*% eg$vectors[1,]
B1
B1 <-  eg$vectors[1,] %*% t(eg$vectors[1,])
B1
B1 <- eg$vectors[1,] %*% t(eg$vectors[1,])
mean(t(Y-Y_tilde) %*% (Y-Y_tilde))
Y <- mu + B1%*%(data-mu)+ B2%*%(data-mu)+ B3%*%(data-mu)+ B4%*%(data-mu)
data-mu
Y <- mu + B1%*%(data-mu)+ B2%*%(data-mu)+ B3%*%(data-mu)+ B4%*%(data-mu)
mu
mean(data)
data
lapply(data, fun(x) mean(x))
lapply(data, mean(x))
lapply(data, meanx)
lapply(data, mean)
apply(data, 1, mean)
apply(data, 2, mean)
data <- mvrnorm(n=50, mu, Sigma)
apply(data, 2, mean)
data <- mvrnorm(n=1000000, mu, Sigma)
apply(data, 2, mean)
Y <- t(mu) + B1%*%t(data-mu)+ B2%*%t(data-mu)+ B3%*%t(data-mu)+ B4%*%t(data-mu)
data-mu
t(data - mu)
B1%*%t(data-mu)[,1]
mu
t(mu)
t(mu)[,1]
mu[,1]
t(t(mu))
Y <- t(t(mu)) + B1%*%t(data-mu)+ B2%*%t(data-mu)+ B3%*%t(data-mu)+ B4%*%t(data-mu)
B1 %*% t(data - mu)
s <- B1 %*% t(data - mu)
mu_t <- t(t(mu))
k <- s+mu_t
k <- t(s)+t(mu_t)
Y <-  apply (B1%*%t(data-mu)+ B2%*%t(data-mu)+ B3%*%t(data-mu)+ B4%*%t(data-mu), 2, fun(x) x+mu)
Y <-  apply (B1%*%t(data-mu)+ B2%*%t(data-mu)+ B3%*%t(data-mu)+ B4%*%t(data-mu), 2, function(x) x+mu)
B1 <- eg$vectors[1,] %*% t(eg$vectors[1,])
B2 <- eg$vectors[2,] %*% t(eg$vectors[2,])
B3 <- eg$vectors[3,] %*% t(eg$vectors[3,])
B4 <- eg$vectors[4,] %*% t(eg$vectors[4,])
Y <-  apply (B1%*%t(data-mu)+ B2%*%t(data-mu)+ B3%*%t(data-mu)+ B4%*%t(data-mu), 2, function(x) x+mu)
Y_tilde <- apply(B1%*%t(data-mu)+ B2%*%t(data-mu), 2, function(x) x+mu)
m <- t(Y-Y_tilde) %*% (Y-Y_tilde)
e <- Y-Y_tilde
m <- t(e) %*% (e)
data <- mvrnorm(n=1000, mu, Sigma)
eg <- eigen(Sigma)
eg$vectors
B1 <- eg$vectors[1,] %*% t(eg$vectors[1,])
B2 <- eg$vectors[2,] %*% t(eg$vectors[2,])
B3 <- eg$vectors[3,] %*% t(eg$vectors[3,])
B4 <- eg$vectors[4,] %*% t(eg$vectors[4,])
Y <-  apply(B1%*%t(data-mu)+ B2%*%t(data-mu)+ B3%*%t(data-mu)+ B4%*%t(data-mu), 2, function(x) x+mu)
Y_tilde <- apply(B1%*%t(data-mu)+ B2%*%t(data-mu), 2, function(x) x+mu)
e <- Y-Y_tilde
m <- t(e) %*% (e)
x <- data[,1]
x <- data[1,]
Y <- mu + B1%*%t(x-mu)+ B2%*%t(x-mu)+ B3%*%t(data-mu)+ B4%*%t(x-mu)
x-mu
m[,1]
m[1,]
mean(m[1,])
eg$values
mean(m)
mean(diag(m))
my.diag <- diag(m)
mean(my.diag)
eg <- eigen(Sigma)
eg$values
e <- Y-Y_tilde
e <- Y-Y_tilde
m <- t(e) %*% (e)
m
diag(m)
m <- e %*% e
m <- e * e
m
mean(m)
eg.values
eg.values
eg$values
eg <- eigen(Sigma)
eg$vectors
B1 <- eg$vectors[1,] %*% t(eg$vectors[1,])
B2 <- eg$vectors[2,] %*% t(eg$vectors[2,])
B3 <- eg$vectors[3,] %*% t(eg$vectors[3,])
B4 <- eg$vectors[4,] %*% t(eg$vectors[4,])
Y <-  apply(B1%*%t(data-mu)+ B2%*%t(data-mu)+ B3%*%t(data-mu)+ B4%*%t(data-mu), 2, function(x) x+mu)
Y_tilde <- apply(B1%*%t(data-mu)+ B2%*%t(data-mu), 2, function(x) x+mu)
e <- Y-Y_tilde
m <- e * e
calcY_YTilde <- function(x){
Y <- mu + B1%*%t(x-mu)+ B2%*%t(x-mu)+ B3%*%t(data-mu)+ B4%*%t(x-mu)
}
m
dim(m)
dim(e)
m <- t(e) %*% e
dim(m)
d <- diag(m)
d
dim(d)
length(d)
mean(d)
u <- c(eg$vectors[1], eg$vectors[2]) %*% (data-mu)
u <- t( c(eg$vectors[1], eg$vectors[2]) )%*% (data-mu)
dim(data-mu)
dim(data)
dim(mu)
t(data) - mu
u <- t( eg$vectors )%*% (t(data)-mu)
Y <-  apply(B1%*%( t(data) - mu)+ B2%*%( t(data) -mu)+ B3%*%( t(data) -mu)+ B4%*%( t(data)-mu), 2, function(x) x+mu)
Y_tilde <- apply(B1%*%( t(data) -mu)+ B2%*%( t(data) -mu), 2, function(x) x+mu)
e <- Y-Y_tilde
m <- t(e) %*% e
ans.is <- mean(diag(m))
ans.is
data - mu == t(data-mu)
data - mu == t(data) - mu
mu
u <- t( c(eg$vectors[1], eg$vectors[2]) )%*% t(data-mu)
dim(data)
u <- t( c(eg$vectors[1], eg$vectors[2]) )%*% (t(data)-mu)
eg$vectors
u <- t( t( c(eg$vectors[1], eg$vectors[2]) ))%*% t(t(data)-mu)
u <- t( t( c(eg$vectors[1], eg$vectors[2]) ))%*% (t(data)-mu)
u
s <- apply(e,2,FUN=function(x){t(x)%*%x})
mean(s)
princomp(data)
# dplyr complains this required libraries: libudunits2-dev, libmariadb-client-lgpl-dev
# install.packages("plotly", repos="http://cran.rstudio.com/", dependencies=TRUE)
# sometimes need to remove all installed packages: https://www.r-bloggers.com/how-to-remove-all-user-installed-packages-in-r/
list.of.packages <- c(
"shiny", "shinyAce", "shinyBS", "plotly",
"RSQLite", "gplots",
"ggplot2", "dplyr", #"tidyverse",
"plotly",
"e1071", "reshape2", "DT",
"data.table", "Rcpp","WGCNA","flashClust","statmod","biclust","igraph","Rtsne"
)
list.of.bio.packages  <- c(
"limma", "DESeq2", "edgeR", "gage", "PGSEA", "fgsea", "ReactomePA", "pathview", "PREDA",
"impute", "runibic","QUBIC","rhdf5",
"PREDAsampledata", "sfsmisc", "lokern", "multtest", "hgu133plus2.db",
"org.Ag.eg.db","org.At.tair.db","org.Bt.eg.db","org.Ce.eg.db","org.Cf.eg.db",
"org.Dm.eg.db","org.Dr.eg.db","org.EcK12.eg.db","org.EcSakai.eg.db","org.Gg.eg.db",
"org.Hs.eg.db","org.Hs.ipi.db","org.Mm.eg.db","org.Mmu.eg.db","org.Pf.plasmo.db",
"org.Pt.eg.db","org.Rn.eg.db","org.Sc.sgd.db","org.Sco.eg.db","org.Ss.eg.db",
"org.Tgondii.eg.db","org.Xl.eg.db"
)
if(0) { # remove all old packages, to solve problem caused by Bioconductor upgrade
# create a list of all installed packages
ip <- as.data.frame(installed.packages())
head(ip)
# if you use MRO, make sure that no packages in this library will be removed
ip <- subset(ip, !grepl("MRO", ip$LibPath))
# we don't want to remove base or recommended packages either\
ip <- ip[!(ip[,"Priority"] %in% c("base", "recommended")),]
# determine the library where the packages are installed
path.lib <- unique(ip$LibPath)
# create a vector with all the names of the packages you want to remove
pkgs.to.remove <- ip[,1]
head(pkgs.to.remove)
# remove the packages
sapply(pkgs.to.remove, remove.packages, lib = path.lib)
}
#Install Require packages
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos="http://cran.rstudio.com/", dependencies=TRUE)
new.bio.packages <- list.of.bio.packages[!(list.of.bio.packages %in% installed.packages()[,"Package"])]
if(length(new.bio.packages)){
source("https://bioconductor.org/biocLite.R")
biocLite(new.bio.packages, suppressUpdates = T)
}
#Load Packages
suc = unlist ( lapply(list.of.packages, require, character.only = TRUE) )
if(sum(suc) < length(list.of.packages) )
cat ("\n\nWarnning!!!!!! These R packages cannot be loaded:", list.of.packages[!suc] )
suc = unlist ( lapply(list.of.bio.packages, require, character.only = TRUE) )
if(sum(suc) < length(list.of.bio.packages) )
cat ("\n\nWarnning!!!!!! These Bioconductor packages cannot be loaded:", list.of.bio.packages[!suc] )
sessionInfo()
shiny::runApp('idep/shinyapps/idep')
# dplyr complains this required libraries: libudunits2-dev, libmariadb-client-lgpl-dev
# install.packages("plotly", repos="http://cran.rstudio.com/", dependencies=TRUE)
# sometimes need to remove all installed packages: https://www.r-bloggers.com/how-to-remove-all-user-installed-packages-in-r/
list.of.packages <- c(
"shiny", "shinyAce", "shinyBS", "plotly",
"RSQLite", "gplots",
"ggplot2", "dplyr", #"tidyverse",
"plotly",
"e1071", "reshape2", "DT",
"data.table", "Rcpp","WGCNA","flashClust","statmod","biclust","igraph","Rtsne"
)
list.of.bio.packages  <- c(
"limma", "DESeq2", "edgeR", "gage", "PGSEA", "fgsea", "ReactomePA", "pathview", "PREDA",
"impute", "runibic","QUBIC","rhdf5",
"PREDAsampledata", "sfsmisc", "lokern", "multtest", "hgu133plus2.db",
"org.Ag.eg.db","org.At.tair.db","org.Bt.eg.db","org.Ce.eg.db","org.Cf.eg.db",
"org.Dm.eg.db","org.Dr.eg.db","org.EcK12.eg.db","org.EcSakai.eg.db","org.Gg.eg.db",
"org.Hs.eg.db","org.Hs.ipi.db","org.Mm.eg.db","org.Mmu.eg.db","org.Pf.plasmo.db",
"org.Pt.eg.db","org.Rn.eg.db","org.Sc.sgd.db","org.Sco.eg.db","org.Ss.eg.db",
"org.Tgondii.eg.db","org.Xl.eg.db"
)
if(0) { # remove all old packages, to solve problem caused by Bioconductor upgrade
# create a list of all installed packages
ip <- as.data.frame(installed.packages())
head(ip)
# if you use MRO, make sure that no packages in this library will be removed
ip <- subset(ip, !grepl("MRO", ip$LibPath))
# we don't want to remove base or recommended packages either\
ip <- ip[!(ip[,"Priority"] %in% c("base", "recommended")),]
# determine the library where the packages are installed
path.lib <- unique(ip$LibPath)
# create a vector with all the names of the packages you want to remove
pkgs.to.remove <- ip[,1]
head(pkgs.to.remove)
# remove the packages
sapply(pkgs.to.remove, remove.packages, lib = path.lib)
}
#Install Require packages
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos="http://cran.rstudio.com/", dependencies=TRUE)
new.bio.packages <- list.of.bio.packages[!(list.of.bio.packages %in% installed.packages()[,"Package"])]
if(length(new.bio.packages)){
source("https://bioconductor.org/biocLite.R")
biocLite(new.bio.packages, suppressUpdates = T)
}
#Load Packages
suc = unlist ( lapply(list.of.packages, require, character.only = TRUE) )
if(sum(suc) < length(list.of.packages) )
cat ("\n\nWarnning!!!!!! These R packages cannot be loaded:", list.of.packages[!suc] )
suc = unlist ( lapply(list.of.bio.packages, require, character.only = TRUE) )
if(sum(suc) < length(list.of.bio.packages) )
cat ("\n\nWarnning!!!!!! These Bioconductor packages cannot be loaded:", list.of.bio.packages[!suc] )
shiny::runApp('idep/shinyapps/idep')
packageVersion('digest')
install.packages('digest')
load("C:/GitRepo/SanfordProfile/export_userinfo_weightmeasure_activity_homestore_MealPlan.rds")
readRDS("C:/GitRepo/SanfordProfile/export_userinfo_weightmeasure_activity_homestore_MealPlan.rds")
sanfordData <- readRDS("C:/GitRepo/SanfordProfile/export_userinfo_weightmeasure_activity_homestore_MealPlan.rds")
sanfordData$age <- sanfordData$age * -1
head(sanfordData$age)
saveRDS(sanfordData, file="C:/GitRepo/SanfordProfile/export_userinfo_weightmeasure_activity_homestore_MealPlan2.rds")
install.packages("xml")
install.packages("XML")
library(XML)
source("https://bioconductor.org/biocLite.R")
biocLite()
biocLite(pkgs = c("limma"), quiet=TRUE)
source("https://bioconductor.org/biocLite.R")
biocLite(pkgs = c("limma"), quiet=TRUE)
deviceNames <- NULL
for(i in 1:28){
deviceNames <- c( deviceNames, paste('device_weight_mean_', i, sep = "" ))
}
deviceNames
devtools::install_github("rstudio/keras")
devtools::install_github("rstudio/keras")
install.packages(c('reticulate', 'tfruns'))
install.packages(c("reticulate", "tfruns"))
devtools::install_github("rstudio/keras")
gene.count <- read.table("Missouri Data Result/genes.count_table", header = TRUE)
gene.attr <- read.table("Missouri Data Result/genes.attr_table", header = TRUE)
setwd("C:/GitRepo/MissouriRelatedDataPreprocess")
gene.count <- read.table("Missouri Data Result/genes.count_table", header = TRUE)
gene.attr <- read.table("Missouri Data Result/genes.attr_table", header = TRUE)
gene.fpkm <- read.table("Missouri Data Result/genes.fpkm_table", header = TRUE)
View(gene.fpkm)
View(gene.attr)
s <- read.table("Missouri Data Result/cds.attr_table", header = TRUE)
View(s)
write.csv(PC3M, file="pc3m.csv", row.names = FALSE)
gene.count <- read.table("Missouri Data Result/genes.count_table", header = TRUE)
library(dplyr)
gene.attr <- read.table("Missouri Data Result/genes.attr_table", header = TRUE)
gene.tracking.name <- gene.attr %>% select(one_of(c("tracking_id", "gene_short_name")))
rawresult <- dplyr::left_join(gene.count, gene.tracking.name, by="tracking_id")
PC3M<-rawresult %>%
select(one_of(c('gene_short_name', 'q7_0', 'q8_0', 'q9_0', 'q10_0', 'q11_0', 'q12_0') ))
colnames(PC3M) <- c('gene_short_name', 'PC3MNT1', 'PC3MNT2', 'PC3MNT3', 'PC3MTR1', 'PC3MTR2', 'PC3MTR3')
write.csv(PC3M, file="pc3m.csv", row.names = FALSE)
write.csv(PC3M, file="pc3m.csv", row.names = FALSE)
source("https://bioconductor.org/biocLite.R")
biocLite("biomaRt")
